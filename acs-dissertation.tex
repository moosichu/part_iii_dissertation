%%
%% ACS project dissertation template.
%%
%% Currently designed for printing two-sided, but if you prefer to
%% print single-sided just remove ",twoside,openright" from the
%% \documentclass[] line below.
%%
%%
%%   SMH, May 2010.


\documentclass[a4paper,12pt,twoside,openright]{report}


%%
%% EDIT THE BELOW TO CUSTOMIZE
%%

\def\authorname{Tom M. Read Cutting\xspace}
\def\authorcollege{Downing College\xspace}
\def\authoremail{tr395@cam.ac.uk}
\def\dissertationtitle{Heterogeneous type checking in multi-language CPU-GPU systems}
\def\wordcount{TODO}


\usepackage{epsfig,graphicx,hyperref,parskip,setspace,tabularx,xspace}
\graphicspath{ {images/} }

%% START OF DOCUMENT
\begin{document}


%% FRONTMATTER (TITLE PAGE, DECLARATION, ABSTRACT, ETC)
\pagestyle{empty}
\singlespacing
\input{titlepage}
\onehalfspacing
\input{declaration}
\singlespacing
\input{abstract}

\pagenumbering{roman}
\setcounter{page}{0}
\pagestyle{plain}
\tableofcontents
\listoffigures
\listoftables

\onehalfspacing

%% START OF MAIN TEXT

\chapter{Introduction}
\pagenumbering{arabic}
\setcounter{page}{1}

Despite the slow-down in the increase of transistor density in recent years
\cite{TODO}, Graphical Processing Units (GPUs) have provided significant gains
in computing power compared with CPUs \cite{TODO}. Furthermore, the growth of
General Purpose GPU (GPGPU) computations have made GPUs applicable outside of
their traditional domain of real-time graphics rendering for video games.

However despite this shift, the toolchains used to interact with GPUs still
suffer from many of the problems they did when their use cases were fairly
niche. Although there has been research into developing modern systems which
can target heterogeneous platforms in more user-friendly ways, they sacrifice
the control that traditional pipelines offer.

I created two systems for type-checking programs accross language boundaries in
CPU-GPU systems. The first is a pre-processing system for C and GLSL that
operates on annotated sections of code. The second is a proof-of-concept pair
of languages with the features provided by the pre-processing system baked-into
the type system at the language level.


TODO: Flesh out.

\section{Overview}

% This is the introduction where you should introduce your work.  In
% general the thing to aim for here is to describe a little bit of the
% context for your work --- why did you do it (motivation), what was the
% hoped-for outcome (aims) --- as well as trying to give a brief
% overview of what you actually did.

% It's often useful to bring forward some ``highlights'' into
% this chapter (e.g.\ some particularly compelling results, or
% a particularly interesting finding).

% It's also traditional to give an outline of the rest of the
% document, although without care this can appear formulaic
% and tedious. Your call.

TODO: Give overview of paper.

\chapter{Technical Background}

% A more extensive coverage of what's required to understand your
% work. In general you should assume the reader has a good undergraduate
% degree in computer science, but is not necessarily an expert in
% the particular area you've been working on. Hence this chapter
% may need to summarize some ``text book'' material.

% This is not something you'd normally require in an academic paper,
% and it may not be appropriate for your particular circumstances.
% Indeed, in some cases it's possible to cover all of the ``background''
% material either in the introduction or at appropriate places in
% the rest of the dissertation.

% This chapter covers relevant (and typically, recent) research
% which you build upon (or improve upon). There are two complementary
% goals for this chapter:
% \begin{enumerate}
%   \item to show that you know and understand the state of the art; and
%   \item to put your work in context
% \end{enumerate}

% Ideally you can tackle both together by providing a critique of
% related work, and describing what is insufficient (and how you do
% better!)

% The related work chapter should usually come either near the front or
% near the back of the dissertation. The advantage of the former is that
% you get to build the argument for why your work is important before
% presenting your solution(s) in later chapters; the advantage of the
% latter is that don't have to forward reference to your solution too
% much. The correct choice will depend on what you're writing up, and
% your own personal preference.

\section{A (brief) History of GPUs}

Graphics Processing Units (GPUs) were originally designed to be fixed-function
3D graphics hardware accelerators aimed at hobbyist gamers who wanted to play
the latest and greatest games with the prettiest graphics possible \cite{TODO}.
However, as video game developers wanted more artistic control over what was
rendered, the \textit{shader model} was introduced which gave graphics
programmers some control ove how computer graphics were rendered. Although
initially simple, as the desire for flexibility over these systems increased,
the capabilities of graphics cards themselves did so as well, reaching a point
where they are now essentially highly-parallel general-purpose computation
machines. A lot of the early (and current) development of GPUs has been driven
by a desire to increase the capabilities they offer to video games, allowing
them to drive not just traditional rendering, but also physics \cite{TODO},
procedural world generation \cite{TODO}, post-processing effects \cite{TODO}
and alternative types of rendering including ray-tracing \cite{TODO}.

However, this increase in flexibility has allowed GPUs be used in increasingly
general domains, including scientific computing \cite{TODO}, crypto-currency
mining \cite{TODO}, video-processing \cite{TODO} and artificial intelligence
\cite{TODO}. To the point where the hobbyists the cards were originally
designed for are being priced out of the market \cite{TODO}.

\section{The Challenges with the APIs}

This section gives an overview of the general challenges programmers face when
using graphics APIs. Firstly, the context and history of graphics APIs are
described, with a focus on OpenGL and Vulkan. Subsequently, the general
workflow of writing programs for GPUs is described, before finally the
individual problems that type heterogeneous type safety seeks to address are
identified.

Programmers interact with GPUs using APIs, however, as the development of and
growth of GPUs in computing has been relatively organic and ad-hoc, these APIs
themselves have many legacy components and can be difficult to work with.

To understand the challenges of working GPUs, one must first understand the
current workflow of GPUs and how that workflow has developed over time.

The best point of comparison is the CPU, and programming for the CPU. When
programming for the CPU, programmers often have access to a plethora of
programming languages which are suited to different needs and are capable of
targeting a wide range of backends. Furthermore, the instruction sets of CPUs
are published and well-documented, allowing programmers to write applications
for them directly - even allowing them to write their own compiler for them if
they so desire. Finally, in the world of desktop computing, x86 is the de-facto
standard architecture, massively increasing the portability of programs which
target desktop PCs without the need for hardware abstractions which could come
with performance penalties.

The workflow of the GPU is very different.

\subsection{OpenGL}

Although GPUs do not have a standard ISA, open standards for GPU computing have
been developed and maintained by the Khronos Group \cite{TODO}, which was
founded in 2000 by a group companies for this purpose. OpenGL is the most
widely used standard graphics API that they maintain, however, the API has a
history dating back to the early 1990's \cite{TODO}, with control of the
standard being passed from Silicon Graphics in 2006 \cite{TODO}. For a long
time the OpenGL family of graphics APIs were the only cross-platform family of
graphics APIs, with OpenGL ES, a related API, being used for mobile and
embedded systems \cite{TODO}.

Despite OpenGL being an open standard with a differently-flavoured API for
non-desktop systems, portability and development using the API is difficult for
several reasons. The focus of this is on the language-aspects of graphics
programming.

The largest competitor to OpenGL has been Direct3D by Microsoft, and is an
alternative graphics API for Windows computers \cite{TODO}. Other platforms may
have their own proprietary graphics APIs, such a Metal for Apple devices
\cite{TODO}, and the various APIs that gaming consoles provide \cite{TODO}.
Although each of these platforms have their differences, the problems being
tackled can be generalised to all of them. Therefore, this paper will purely
focus on the OpenGL family of graphics APIs.

\subsection{Vulkan}

TODO:

\subsection{Graphics workflow and pipeline}

GPUs are highly parallel compute machines capable of running programs called
\textit{shaders}. However, unlike CPU programs, where a programmer will simply
start writing code in a \texttt{main} function which can be straightforwardly
compiled and executed, shaders require more setup and boilerplate. Typically,
shaders complement programs designed for the CPU, with the traditional example
being a video game. In this case, the core components of a game (such as logic,
animation, scene-setup, input handling) will be handled by the CPU which can
then offload certain computations to the GPU (such as graphics and physics).
The programmer does this by using graphics APIs to initialise the graphics
pipeline to the desired state for a particular computation (setting up buffers,
loading data onto the GPU, initialising the pipeline, reserving resources,
etc.). Following this, those APIs are used to direct the drivers to load
\textit{shader code} onto the GPU. Finally, the shaders are executed for the
desired results.

Although laborious, this workflow allows programmers to use the resources of
GPUs fairly efficiently. However, it is not without issues. The one which this
paper seeks to tackle is down to the fact that \textit{shaders} and CPU code
are written in completely different programming languages.

List to cover:

 - standard has a lot of legacy and issues:
    - different workflows and APIs for different applications
    - non-standard implementations of the standard, with vendor-specific extenions
    and other propietary technologies.
    - standard changes depending on whether targeting desktop, mobile or
    embedded systems
    - must interact with Operating systems directly, such as using their windowing
    system to create a \textit{context}. This reduces portabililty.
    - Langauges are compiled at run-time, with different shader-models
    - Companie wil partner with different vendors

\chapter{Design}

The heterogeneous type checking aspects of the projects is composed of two
alternative systems. The first is a pre-processing system for C and GLSL that
ensures the enforcement of interfaces between the two languages. The second is
a set of two novel toy languages which natively support such enforcement.

\section{Workflow}

One of the important parts of the system is the implementation of the workflow.

\section{Lexer}

TODO:

\section{Parser}

TODO:

\section{Semantic Analysis}

TODO:

\chapter{Implementation}

% This chapter may be called something else\ldots but in general
% the idea is that you have one (or a few) ``meat'' chapters which
% describe the work you did in technical detail.

TODO:

TODO: reference usage of FNV hash for symbol table. \cite{FNVHash}.



\chapter{Evaluation}

% For any practical projects, you should almost certainly have
% some kind of evaluation, and it's often useful to separate
% this out into its own chapter.

TODO:

\chapter{Conclusion and Further Work}

% As you might imagine: summarizes the dissertation, and draws
% any conclusions. Depending on the length of your work, and
% how well you write, you may not need a summary here.

% You will generally want to draw some conclusions, and point
% to potential future work. \cite{DirectXWorkings}

TODO:

\chapter{Related Work}

TODO: Discuss all related work in the field.

\appendix
\singlespacing

\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
