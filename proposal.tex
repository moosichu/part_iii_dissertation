\documentclass[11pt]{article}
\usepackage{a4wide,parskip,times}
\usepackage{cite}

\begin{document}

\centerline{\Large Late-Bound computing in CPU-GPU systems}
\vspace{2em}
\centerline{\Large \emph{A PartIII project proposal}}
\vspace{2em}
\centerline{\large T. M. Read Cutting (\emph{tr395}), Downing College}
\vspace{1em}
\centerline{\large Project Supervisor: Prof A. Mycroft}
\vspace{1em}

\begin{abstract}

Programming for the GPU can be complex, error-prone and hard to manage using
existing tool chains, as programmers are required to write code in different
languages for the GPU and CPU, with little to no runtime or compile-time safety
across the boundaries between them. Various research has been done into
creating and designing unified programming languages which can be compiled to
heterogeneous architectures with systems to allocate load at runtime and handle
parallelisation and vectorisation automatically, greatly simplifying the
programming workflow. However, these languages are either domain specific or
have otherwise yet to experience serious uptake in soft real-time computing due
to various factors, including runtime overhead, lack of low-level control, and
other inefficiencies which make them unsuitable for soft real-time
applications. The result of this is that existing tool chains have not
developed alongside the existing research which aims to target systems of the
future as opposed to acknowledging the current state of affairs.

This project proposes a pragmatic solution of using a hybrid system composed of
two programming languages which each compile down to their respective
architectures (CPU/GPU), similar to existing workflows. This project
contributes to the field in providing a unified type-checking system across the
two languages in order to eliminate common errors - with the ability to use
type-safe syntactic sugar that compiles down to the boilerplate code that
handles API calls across the CPU/GPU boundary.

\end{abstract}

\section{Introduction, approach and outcomes (500 words)}

Increasing amounts of general computation is being offloaded to GPUs in soft
real time systems such as games \cite{GPGPUTechniques2012}.

Graphics processing units are being used more and more for general purpose
computations in games. However, many existing APIâ€™s have a lot of baggage in
terms of verbosity due to their long history (OpenGL, DirectX), making them
hard to use. Therefore, in addition to the complexity of designing and writing
algorithms which behave nicely using GPUs, getting them to run in practise is
complicated in terms of ensuring everything is setup just right in order to get
results. Writing shaders themselves is relatively straight forward, it's
managing the interface that is hard. Furthermore, even once written, minor
changes can have unintended effects which lead to the code you have no longer
running correctly. Vulkan, a new and low-level API, is seeking to change this,
with an intermediate shading language known as SPIR-V, partly designed for the
purpose of custom front-end languages on GPU beyond HLSL and GLSL.

There have been many projects and tools which aim to manage these complications
at different levels, however, the domain specificity of these project, the
abstractions, or performance consideration of them, have made them unsuitable
for real-time applications such as games. There have been many projects, which
aim to automatically compile code written in a language to a wide variety of
heterogenous systems. Unfortunately though, the abstractions they provide make
them unsuitable for games programming. There are also some individuals in the
games industry, making movements towards designing or using alternative
languages to C++, leading to exciting opportunities in this space.

My project will be to design and implement a simple imperative language with
two flavours - one for the CPU and one for the GPU. This will be done
iteratively, by targetting individual components in the existing workflow and
designing language features which make them less cumbersome. The aims of this
project are to provide compile-time guarantees that certain errors on the
inteface between the GPU and CPU aren't present, so there shouldn't be any
runtime cost.

By the end I will have produced a language design and associated compiler that
can be used to compile the language, with suitable components being compiled for
a CPU and GPU backend.

My evaluation will consist of demonstrating which problems have been sovled,
showing equivalent C/GLSL where they can be easily be introduced, and showing
how the new language doesn't won't compile with them whilst still having the
similar runtime performance. As the focus of this isn't on compile-time
optimisations, the testing will be performed with compiler optimisations
disabled.

\section{Workplan (500 words)}

Counting from the 1st of December to the aimed submission date of the 27th of
November there are 25 weeks. So I will plan for 24 weeks of work, including a
grace week in case I fall behind.

Some stuff here.

\bibliography{references}
\bibliographystyle{ieeetr}

\newpage
\appendix

\section{Time Table}

\subsection{Weeks 1-2 (20 hours)}

Write 5 sample programs with a Vulkan backend in C/GLSL that can be used to
demonstrate the common issues a new language design could solve. It is
important that these programs use a subset of the features available in C/GLSL.
As the goal of the language is not to re-implement existing languages, but
demonstrate how a language could be designed to solve these common problems.
One of the programs can be for the CPU only for testing purposes.

\subsection{Weeks 3-4 (25 hours)}

'Port' the sample programs to what they would ideally look like in the
front-end of a new language. Send these off for feedback from the project
supervisor. Start designing a grammar for the language for parsing.

\subsection{Weeks 5-6 (30 hours)}

Implement a parser for the language and construct an AST of each example pro-
grams. Implement a type-checker that operates on the AST and demonstrate it can
catch the errors the can be easily demonstrated to occur. Have an intepreter be
able to run the AST for the CPU-only and give the same result as the
C-equivalent.

\subsection{Weeks 7-8 (20 hours)}

Compile the AST to bytecode.

\subsection{Weeks 9-10 (20 hours)}

Compile the CPU side bytecode to an LLVM backend.

\subsection{Weeks 11-12 (20 hours)}

Compile the GPU side bytecode to a SPIR-V backend.

\subsection{Weeks 13-14 (30 hours)}

Demonstrate that the sample programs compile and run.

\subsection{Weeks 15-16 (40 hours)}

Flesh-out and demonstrate more ideas. Use these two weeks to investigate
further directions this could go and implement any possible extensions. Polish
is the main focus here.

\subsection{Weeks 17-18 (40 hours)}

Perform the evaluation.

\subsection{Weeks 19-20 (40 hours)}

Write the first draft of the dissertation. Send it to my project supervisor for
feedback. Work on developing the software further in any spare time.

\subsection{Weeks 21-22 (40 hours)}

Write second draft of the dissertation.

Send it to my project supervisor for feedback. Work on developing the software
further in any spare time.


\subsection{Weeks 23-24 (40 hours)}

Write final draft of the dissertation. Send it to my project supervisor for
feedback. Work on developing the software further in any spare time. Submit
final project.

\section{Related Work}

\section{Example of boilerplate elimination and error checking}

TODO:




\end{document}
