\newpage
{\Huge \bf Abstract}
\vspace{24pt}

% 1 sentence setting out the the scene, future holds promise.

% this thesis sets scene then give contributions.

% TODO: so step back and look at heterogenous computing

% TODO: because compiled in seperate languages, use better words

% 2. Paper explores cross module checking between languages.

Programming for heterogeneous architectures such as CPU-GPU systems can be
frustrating and error-prone due to the need to use incompatible programming
languages designed for different target architectures. Programmers have to
manually ensure that shared data structures and types are consistent on the
boundaries between code for different architectures -- even when targeting them
with high-level and internally-sound programming languages.

There are multiple approaches that can be used to ease this burden. One
approach is to use unified languages which natively target heterogeneous
architectures. However, currently these languages are either domain-specific or
do not provide programmers the control necessary to achieve the performance
levels that traditional workflows can provide.

This paper explores and discusses the implementation of two prapproaches for
cross-module type checking between languages, \textbf{AnnoCheck} and
\textbf{CUG}. Each approach targets components of heterogeneous computing
systems without sacrificing the performance modern systems provide. Although
the ideas are applicable to general heterogeneous systems, the focus for this
paper is on type checking between languages which target GPUs and CPUs.

\textit{AnnoCheck} is a pragmatic front-end pre-processor for the C and GLSL
programming languages to ensure the compile-time type-safety of the data
transferred between them. Due to limitations with this approach, we developed
\textit{CUG}, a single programming language with two distinct
\textit{dialects}. Each of these approaches have their pros and cons, but they
have the same fundamental goal: improving the user experience of programming
for heterogeneous architectures relative to the status quo, whilst still
offering the level of control that traditional workflows provide. This is done
so that runtime performance is not compromised.

We demonstrate how common errors that can occur when programming for GPUs using
C and GLSL are caught by the cross-module type checking systems. We then show
how these systems can be used to write various sound C and GLSL programs with
identical runtime performance to their unchecked counterparts.

\newpage
\vspace*{\fill}
