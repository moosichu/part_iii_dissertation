\newpage
{\Huge \bf Abstract}
\vspace{24pt}

% 1 sentence setting out the the scene, future holds promise.

% this thesis sets scene then give contributions.

% TODO: so step back and look at heterogenous computing

% TODO: because compiled in seperate languages, use better words

% 2. Paper explores cross module checking between languages.

Programming for heterogeneous architectures such as CPU-GPU systems can be
frustrating and error-prone due to the requirement of using incompatible
programming languages designed for distinct target backends. Programmers have
to contend with manually ensuring ahared data structures and types are
consistent on the boundaries between code for different systems - even when
targeting them with high-level and internally-sound programming languages.

There are multiple approaches that can be used to ease this burden. For
example, the future holds promise with unified languages which target
heterogeneous architectures. However, these languages are currently either
domain specific \cite{DSL1} \cite{DSL2} or lack the control necessary to
achieve the performance levels that traditional workflows provide
\cite{Lime2010} \cite{JCUDA2009}.

This paper explores and discusses the implementation of two mechanisms for
cross-module type checking between languages for heterogeneous computing
systems without sacrificing the control modern systems provide. Although the
ideas are applicable to general heterogeneous systems, the focus for this paper
is on GPUs and CPUs.

Th first mechanism is a front-end pre-processor for the C and GLSL programming
languages to ensure the compile-time type-safety of the data transferred
between them. The second mechanism is a pair of programming languages with
compatible type systems. Both of these approaches have their own trade-offs,
with the goal of improving the user experience when interacting with GPUs
whilst still offering the level of control that traditional workflows provide.

\newpage
\vspace*{\fill}
