\newpage
{\Huge \bf Abstract}
\vspace{24pt}

% 1 sentence setting out the the scene, future holds promise.

% this thesis sets scene then give contributions.

% TODO: so step back and look at heterogenous computing

% TODO: because compiled in seperate languages, use better words

% 2. Paper explores cross module checking between languages.

Programming for heterogeneous architectures such as CPU-GPU systems can be
frustrating and error-prone due to the requirement of using incompatible
programming languages designed for different target architectures. Programmers
have to contend with manually ensuring shared data structures and types are
consistent on the boundaries between code for different architectures -- even
when targeting them with high-level and internally-sound programming languages.

There are multiple approaches that can be used to ease this burden. One
approach is to use unified languages which natively target heterogeneous
architectures. However, currently these languages are either domain-specific or
do not provide programmers the control necessary to achieve the performance
levels that traditional workflows can provide.

This paper explores and discusses the implementation of two systems for
cross-module type checking between languages. These languages each target
components of heterogeneous computing systems without sacrificing the
performance modern systems provide. Although the ideas are applicable to
general heterogeneous systems, the focus for this paper is on type checking
between languages which target GPUs and CPUs.

The first system for cross-module checking is a front-end pre-processor for the
C and GLSL programming languages to ensure the compile-time type-safety of the
data transferred between them. The second system is a pair of distinct
programming languages with compatible type systems. Both of these approaches
have their own pros and cons, with the goal of improving the user experience of
programming for heterogeneous architectures relative to the status quo, whilst
still offering the level of control that traditional workflows provide. This is
done so that runtime performance is not compromised at all.

We demonstrate how common errors that can occur when programming for GPUs using
C and GLSL are caught by the cross-module type checking systems. We then show
how these systems can theoretically be used to write many sound C and GLSL
programs with identical runtime performance to their unchecked counterparts.

\newpage
\vspace*{\fill}
